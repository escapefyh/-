# 购买订单接口文档

## 1. 创建订单接口

### 1.1 接口信息

- **接口路径**: `/order/create`
- **请求方法**: `POST`
- **接口描述**: 用户购买商品时创建订单（支持直接购买和拼团购买）

### 1.2 请求参数

#### 请求头
```
Content-Type: application/json
```

#### 请求体（JSON）

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| user_id | string/number | 是 | 用户ID（购买者） |
| goods_id | string/number | 是 | 商品ID |
| address_id | string/number | 是 | 收货地址ID |
| quantity | number | 是 | 购买数量（必须大于0） |
| spec_id | string/number | 否 | 规格ID（如果商品开启了规格，则必填）。如果后端没有生成spec_id，前端会传递临时ID（格式：`spec_{index}`），后端需要根据规格名称匹配 |
| spec_name | string | 否 | 规格名称（用于后端验证，防止前端传递错误的spec_id）。如果商品开启了规格，建议同时传递此字段 |
| is_group_buy | boolean | 否 | 是否为拼团购买（true: 拼团购买，false: 直接购买，默认false） |
| total_price | string/number | 是 | 订单总价（保留2位小数的数字或字符串，如 "99.99" 或 99.99） |

#### 请求示例

**直接购买（无规格）**
```json
{
  "user_id": "123",
  "goods_id": "456",
  "address_id": "789",
  "quantity": 2,
  "spec_id": null,
  "is_group_buy": false,
  "total_price": "199.98"
}
```

**直接购买（有规格）**
```json
{
  "user_id": "123",
  "goods_id": "456",
  "address_id": "789",
  "quantity": 1,
  "spec_id": "101",
  "spec_name": "红色",
  "is_group_buy": false,
  "total_price": "99.99"
}
```

**拼团购买**
```json
{
  "user_id": "123",
  "goods_id": "456",
  "address_id": "789",
  "quantity": 1,
  "spec_id": null,
  "is_group_buy": true,
  "total_price": "79.99"
}
```

### 1.3 响应参数

#### 成功响应

**状态码**: `200`

**响应体（JSON）**

| 参数名 | 类型 | 说明 |
|--------|------|------|
| msg | string | 响应消息，成功时为 "success" |
| data | object | 订单数据 |
| data.order_id | string/number | 订单ID |
| data.order_no | string | 订单编号（唯一标识） |
| data.status | string | 订单状态（如：pending, paid, shipped, completed, cancelled） |
| data.total_price | number | 订单总价 |
| data.create_time | string | 订单创建时间（ISO 8601格式） |

**响应示例**
```json
{
  "msg": "success",
  "data": {
    "order_id": "1001",
    "order_no": "ORD20240129123456789",
    "status": "pending",
    "total_price": 199.98,
    "create_time": "2024-01-29T12:34:56.789Z"
  }
}
```

#### 错误响应

**状态码**: `400` 或 `500`

**响应体（JSON）**

| 参数名 | 类型 | 说明 |
|--------|------|------|
| msg | string | 响应消息，失败时为 "error" |
| error | string | 错误描述信息 |

**错误响应示例**
```json
{
  "msg": "error",
  "error": "商品库存不足"
}
```

### 1.4 错误码说明

| 错误码 | 错误信息 | 说明 |
|--------|----------|------|
| 400 | 参数错误 | 请求参数缺失或格式不正确 |
| 400 | 商品不存在 | goods_id 对应的商品不存在 |
| 400 | 商品已下架 | 商品状态不可购买 |
| 400 | 商品库存不足 | 商品或规格的库存数量不足 |
| 400 | 地址不存在 | address_id 对应的地址不存在或不属于当前用户 |
| 400 | 规格不存在 | spec_id 对应的规格不存在或不属于该商品。如果前端传递的是临时ID（格式：`spec_{index}`），后端应根据 `spec_name` 和 `goods_id` 匹配规格 |
| 400 | 拼团未开启 | 商品未开启拼团功能，但 is_group_buy 为 true |
| 400 | 价格不匹配 | total_price 与计算出的价格不一致（防止前端篡改） |
| 401 | 未登录 | user_id 为空或用户未登录 |
| 500 | 服务器错误 | 服务器内部错误 |

### 1.5 业务逻辑说明

1. **价格验证**
   - 后端需要根据 `goods_id`、`spec_id`、`quantity`、`is_group_buy` 重新计算订单总价
   - 如果商品开启了拼团（`is_group_buy = true`），需要应用拼团折扣
   - 将计算出的价格与前端传入的 `total_price` 进行对比，如果差异超过 0.01 元，应返回错误

2. **库存检查**
   - 如果商品开启了规格（`spec_id` 不为空），检查对应规格的库存
   - 如果商品未开启规格，检查商品的库存
   - 库存不足时返回错误
   - **注意**：如果前端传递的 `spec_id` 是临时ID（格式：`spec_{index}`），后端应使用 `spec_name` 和 `goods_id` 查找对应的规格

3. **拼团逻辑**
   - 如果 `is_group_buy = true`，需要检查商品是否开启了拼团功能
   - 拼团订单的价格 = 商品原价 × 拼团折扣 × 数量
   - 拼团订单创建后，可能需要加入或创建拼团组（具体逻辑根据业务需求）

4. **订单状态**
   - 订单创建后，初始状态应为 `pending`（待支付）
   - 订单编号（`order_no`）应保证唯一性，建议使用时间戳 + 随机数生成

### 1.6 前端调用示例

```javascript
// 准备订单数据
const orderData = {
  user_id: wx.getStorageSync('user_id'),
  goods_id: this.data.goods_id,
  address_id: this.data.selectedAddress.address_id,
  quantity: this.data.quantity,
  spec_id: this.data.selectedSpec ? this.data.selectedSpec.spec_id : null,
  is_group_buy: this.data.buyType === 'group',
  total_price: this.data.totalPrice
};

// 调用创建订单接口
const result = await ajax('/order/create', 'POST', orderData);

if (result?.msg === 'success') {
  // 订单创建成功
  console.log('订单ID:', result.data.order_id);
  console.log('订单编号:', result.data.order_no);
} else {
  // 订单创建失败
  console.error('错误:', result?.error);
}
```

---

## 2. 获取地址列表接口（已存在，供参考）

### 2.1 接口信息

- **接口路径**: `/address/list`
- **请求方法**: `GET`
- **接口描述**: 获取用户的收货地址列表

### 2.2 请求参数

#### Query 参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| user_id | string/number | 是 | 用户ID |

#### 请求示例
```
GET /address/list?user_id=123
```

### 2.3 响应参数

#### 成功响应

```json
{
  "msg": "success",
  "data": {
    "list": [
      {
        "address_id": "789",
        "name": "张三",
        "phone": "13800138000",
        "province": "河南省",
        "city": "郑州市",
        "district": "高新区",
        "detail": "科学大道100号",
        "is_default": true
      }
    ]
  }
}
```

---

## 3. 商品详情接口（已存在，供参考）

### 3.1 接口信息

- **接口路径**: `/goods/detail`
- **请求方法**: `GET`
- **接口描述**: 获取商品详情信息

### 3.2 请求参数

#### Query 参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| goods_id | string/number | 是 | 商品ID |

### 3.3 响应参数

#### 成功响应

```json
{
  "msg": "success",
  "data": {
    "goods": {
      "goods_id": "456",
      "description": "商品描述",
      "price": 99.99,
      "stock": 100,
      "spec_enabled": true,
      "specs": [
        {
          "spec_id": "101",
          "name": "规格名称",
          "price": 99.99,
          "stock": 50
        }
      ],
      "group_buy_enabled": true,
      "group_buy_discount": 0.8,
      "group_buy_count": 2,
      "images": ["https://example.com/image1.jpg"]
    },
    "seller": {
      "user_id": "789",
      "nickname": "卖家昵称",
      "avatar": "https://example.com/avatar.jpg"
    }
  }
}
```

---

## 4. 接口调用流程图

```
用户点击购买按钮
    ↓
检查登录状态
    ↓
加载用户信息和地址列表
    ↓
显示购买弹窗
    ↓
用户选择地址、规格、数量
    ↓
计算总价
    ↓
用户点击确认购买
    ↓
调用 /order/create 接口
    ↓
订单创建成功
    ↓
跳转到订单页面
```

---

## 5. 注意事项

1. **价格安全**
   - 前端传入的 `total_price` 仅用于参考，后端必须重新计算并验证
   - 防止用户通过修改前端代码篡改价格

2. **库存并发**
   - 建议使用数据库锁或乐观锁机制，防止并发购买导致超卖

3. **拼团订单**
   - 拼团订单创建后，可能需要额外的逻辑处理（如加入拼团组、创建拼团组等）
   - 具体实现根据业务需求确定

4. **订单状态流转**
   - `pending` → `paid` → `shipped` → `completed`
   - 或 `pending` → `cancelled`

5. **错误处理**
   - 前端应妥善处理各种错误情况，给用户友好的提示
   - 建议对网络错误、参数错误、业务错误进行分类处理

---

## 6. 更新日志

| 日期 | 版本 | 更新内容 |
|------|------|----------|
| 2024-01-29 | 1.0.0 | 初始版本，创建订单接口文档 |

---

## 7. 联系方式

如有问题，请联系后端开发团队。


