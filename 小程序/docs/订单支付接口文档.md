# 订单支付接口文档

## 1. 支付订单接口

### 1.1 接口信息

- **接口路径**: `/order/pay`
- **请求方法**: `POST`
- **接口描述**: 用户支付订单（使用钱包余额支付，模拟支付，不需要真实支付接口）

### 1.2 请求参数

#### 请求头
```
Content-Type: application/json
```

#### 请求体（JSON）

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| user_id | string/number | 是 | 用户ID |
| order_id | string/number | 是 | 订单ID |

#### 请求示例

```json
{
  "user_id": "123",
  "order_id": "456"
}
```

### 1.3 响应参数

#### 成功响应

**状态码**: `200`

**响应体（JSON）**

| 参数名 | 类型 | 说明 |
|--------|------|------|
| msg | string | 响应消息，成功时为 "success" |
| data | object | 支付结果数据 |
| data.order_id | string/number | 订单ID |
| data.order_status | string | 支付后的订单状态（应为 "paid"） |
| data.pay_amount | number | 支付金额 |
| data.balance_after | number | 支付后的账户余额 |
| data.pay_time | string | 支付时间（ISO 8601格式） |

**响应示例**

```json
{
  "msg": "success",
  "data": {
    "order_id": "456",
    "order_status": "paid",
    "pay_amount": 100.00,
    "balance_after": 900.00,
    "pay_time": "2024-01-29T12:34:56.789Z"
  }
}
```

#### 错误响应

**状态码**: `400` 或 `500`

**响应体（JSON）**

| 参数名 | 类型 | 说明 |
|--------|------|------|
| msg | string | 响应消息，失败时为 "error" |
| error | string | 错误描述信息 |

**错误响应示例**

```json
{
  "msg": "error",
  "error": "余额不足"
}
```

### 1.4 错误码说明

| 错误码 | 错误信息 | 说明 |
|--------|----------|------|
| 400 | 参数错误 | 请求参数缺失或格式不正确 |
| 400 | 用户不存在 | user_id 对应的用户不存在 |
| 400 | 订单不存在 | order_id 对应的订单不存在 |
| 400 | 订单状态错误 | 订单状态不是 "pending"（待付款），无法支付 |
| 400 | 余额不足 | 用户钱包余额小于订单金额 |
| 400 | 订单金额不匹配 | 订单金额与请求中的金额不一致（如果后端需要验证） |
| 401 | 未登录 | user_id 为空或用户未登录 |
| 403 | 权限不足 | 用户无权支付该订单（订单不属于该用户） |
| 500 | 服务器错误 | 服务器内部错误（如数据库操作失败、余额扣款失败等） |

### 1.5 业务逻辑说明

1. **订单状态验证**
   - 只有状态为 "pending"（待付款）的订单才能支付
   - 如果订单状态不是 "pending"，应返回错误 "订单状态错误"

2. **用户权限验证**
   - 必须验证订单属于当前用户
   - 如果订单不属于当前用户，应返回错误 "权限不足"

3. **余额检查**
   - 支付前必须检查用户钱包余额是否足够
   - 如果余额不足，应返回错误 "余额不足"
   - 余额检查应在数据库事务中进行，防止并发问题

4. **余额扣款**
   - 支付成功后，从用户钱包余额中扣除订单金额
   - 新余额 = 原余额 - 订单金额
   - 余额应保留2位小数
   - 余额扣款应使用数据库事务，确保原子性

5. **订单状态更新**
   - 支付成功后，将订单状态更新为 "paid"（待发货）
   - 更新订单的支付时间

6. **支付记录**
   - 建议记录每次支付操作，包括：
     - 支付订单ID
     - 用户ID
     - 支付金额
     - 支付前余额
     - 支付后余额
     - 支付时间
   - 支付记录可用于后续的对账、退款等功能

7. **事务处理**
   - 余额扣款和订单状态更新应在同一个数据库事务中完成
   - 如果任何一步失败，应回滚整个操作
   - 确保数据一致性

8. **并发安全**
   - 支付操作应使用数据库锁或乐观锁机制
   - 防止并发支付导致余额计算错误或重复支付

9. **模拟支付说明**
   - 本接口为模拟支付，不需要调用真实的微信支付或支付宝接口
   - 支付后订单状态立即更新为 "paid"，无需等待支付回调
   - 如果后续需要接入真实支付，可以：
     - 保留此接口作为钱包支付接口
     - 新增真实支付接口（如 `/order/pay/wechat`、`/order/pay/alipay`）
     - 或修改此接口，根据参数判断是钱包支付还是真实支付

---

## 2. 获取钱包余额接口（用于支付前检查）

### 2.1 接口信息

- **接口路径**: `/wallet/balance`
- **请求方法**: `GET`
- **接口描述**: 获取用户的账户余额（用于支付前检查余额是否充足）

**注意**: 此接口的详细文档请参考 `钱包接口文档.md`。这里仅作简要说明。

### 2.2 请求参数

#### Query 参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| user_id | string/number | 是 | 用户ID |

### 2.3 响应参数

#### 成功响应

```json
{
  "msg": "success",
  "data": {
    "balance": 1234.56
  }
}
```

**响应字段说明**:
- `balance`: 账户余额（number类型，单位：元，保留2位小数）

---

## 3. 支付流程说明

### 3.1 商品详情页支付流程

```
用户点击"立即购买"
    ↓
填写订单信息（地址、规格、数量等）
    ↓
点击"确认购买"
    ↓
调用 /order/create 创建订单
    ↓
订单创建成功，获取 order_id 和 total_price
    ↓
调用 /wallet/balance 获取钱包余额
    ↓
弹出支付确认窗口
    - 显示支付金额（格式化：保留2位小数）
    - 显示账户余额（格式化：保留2位小数）
    - 显示合计金额（格式化：保留2位小数）
    - 如果余额不足，显示警告提示
    ↓
用户点击"确认支付"
    ↓
前端检查余额是否充足（可选，后端也会检查）
    ↓
调用 /order/pay 执行支付
    ↓
支付成功
    ↓
跳转到订单页面（显示"待发货"状态）
```

### 3.2 订单页面支付流程

```
用户在订单页面点击"去付款"
    ↓
调用 /wallet/balance 获取钱包余额
    ↓
弹出支付确认窗口
    - 显示支付金额（从订单信息获取，格式化：保留2位小数）
    - 显示账户余额（格式化：保留2位小数）
    - 显示合计金额（格式化：保留2位小数）
    - 如果余额不足，显示警告提示
    ↓
用户点击"确认支付"
    ↓
前端检查余额是否充足（可选，后端也会检查）
    ↓
调用 /order/pay 执行支付
    ↓
支付成功
    ↓
刷新订单列表（订单状态更新为"待发货"）
```

### 3.3 余额不足处理

```
用户点击"确认支付"
    ↓
前端/后端检查余额不足
    ↓
显示"余额不足"提示
    - 显示当前余额
    - 显示支付金额
    - 提示"余额不足，请先充值"
    ↓
用户点击"去充值"
    ↓
跳转到钱包页面
    ↓
用户充值后返回订单页面
    ↓
重新点击"去付款"进行支付
```

---

## 4. 前端数据格式说明

### 4.1 金额格式化

**问题**: 微信小程序 WXML 模板中不能直接调用 JavaScript 方法（如 `.toFixed()`），需要在 JS 中先格式化数据。

**解决方案**:
- 在 JS 中将金额格式化为字符串（保留2位小数）
- 在 WXML 中直接显示格式化后的字符串

**示例代码**:

```javascript
// JS 中格式化金额
const payAmount = 100.5;
const payAmountFormatted = payAmount.toFixed(2); // "100.50"

this.setData({
  payAmount: payAmount,              // 数字类型，用于计算
  payAmountFormatted: payAmountFormatted  // 字符串类型，用于显示
});
```

```xml
<!-- WXML 中直接显示格式化后的字符串 -->
<text>¥{{payAmountFormatted}}</text>
```

### 4.2 支付弹窗数据字段

**商品详情页面**:
- `payAmount`: 支付金额（number类型，用于计算和比较）
- `payAmountFormatted`: 支付金额（string类型，用于显示，格式：保留2位小数）
- `walletBalance`: 钱包余额（number类型，用于计算和比较）
- `walletBalanceFormatted`: 钱包余额（string类型，用于显示，格式：保留2位小数）

**订单页面**:
- `currentPayOrder.total_price`: 订单金额（number类型，用于计算和比较）
- `currentPayOrder.total_price_formatted`: 订单金额（string类型，用于显示，格式：保留2位小数）
- `payAmountFormatted`: 支付金额（string类型，用于显示，格式：保留2位小数）
- `walletBalance`: 钱包余额（number类型，用于计算和比较）
- `walletBalanceFormatted`: 钱包余额（string类型，用于显示，格式：保留2位小数）

### 4.3 数据获取时机

1. **商品详情页面**:
   - 创建订单成功后，从订单创建接口返回的 `total_price` 获取支付金额
   - 调用 `/wallet/balance` 接口获取钱包余额
   - 在 `openPayModal` 方法中格式化所有金额数据

2. **订单页面**:
   - 从订单列表中的订单信息获取 `total_price` 或 `total_price_formatted`
   - 调用 `/wallet/balance` 接口获取钱包余额
   - 在 `openPayModal` 方法中格式化所有金额数据

---

## 5. 数据库设计建议

### 5.1 订单表（order）

| 字段名 | 类型 | 说明 | 约束 |
|--------|------|------|------|
| order_id | INT/BIGINT | 订单ID（主键） | PRIMARY KEY, AUTO_INCREMENT |
| order_no | VARCHAR(50) | 订单编号 | NOT NULL, UNIQUE |
| user_id | INT/BIGINT | 用户ID | NOT NULL, FOREIGN KEY |
| goods_id | INT/BIGINT | 商品ID | NOT NULL, FOREIGN KEY |
| status | VARCHAR(20) | 订单状态 | NOT NULL, DEFAULT 'pending' |
| total_price | DECIMAL(10, 2) | 订单总价 | NOT NULL |
| pay_time | DATETIME | 支付时间 | NULL |
| create_time | DATETIME | 创建时间 | NOT NULL |
| update_time | DATETIME | 更新时间 | NOT NULL |

**订单状态说明**:
- `pending`: 待付款
- `paid`: 待发货（已支付）
- `shipped`: 待收货（已发货）
- `completed`: 已完成
- `cancelled`: 已取消

### 5.2 钱包表（wallet）

| 字段名 | 类型 | 说明 | 约束 |
|--------|------|------|------|
| wallet_id | INT/BIGINT | 钱包ID（主键） | PRIMARY KEY, AUTO_INCREMENT |
| user_id | INT/BIGINT | 用户ID | NOT NULL, UNIQUE, FOREIGN KEY |
| balance | DECIMAL(10, 2) | 账户余额 | NOT NULL, DEFAULT 0.00 |
| update_time | DATETIME | 更新时间 | NOT NULL |

### 5.3 支付记录表（payment_record，可选）

| 字段名 | 类型 | 说明 | 约束 |
|--------|------|------|------|
| record_id | INT/BIGINT | 记录ID（主键） | PRIMARY KEY, AUTO_INCREMENT |
| order_id | INT/BIGINT | 订单ID | NOT NULL, FOREIGN KEY |
| user_id | INT/BIGINT | 用户ID | NOT NULL, FOREIGN KEY |
| pay_amount | DECIMAL(10, 2) | 支付金额 | NOT NULL |
| balance_before | DECIMAL(10, 2) | 支付前余额 | NOT NULL |
| balance_after | DECIMAL(10, 2) | 支付后余额 | NOT NULL |
| pay_method | VARCHAR(20) | 支付方式（wallet/wechat/alipay） | NOT NULL, DEFAULT 'wallet' |
| pay_time | DATETIME | 支付时间 | NOT NULL |
| status | VARCHAR(20) | 状态（success/failed） | NOT NULL, DEFAULT 'success' |

---

## 6. 前端调用示例

### 6.1 支付订单

```javascript
// 支付订单
const user_id = wx.getStorageSync('user_id');
const order_id = '456'; // 订单ID

try {
  wx.showLoading({
    title: '支付中...',
    mask: true
  });

  const result = await ajax('/order/pay', 'POST', {
    user_id: user_id,
    order_id: order_id
  });

  wx.hideLoading();

  if (result?.msg === 'success') {
    wx.showToast({
      title: '支付成功',
      icon: 'success'
    });
    // 刷新订单列表或跳转
    this.loadOrderList(true);
  } else {
    wx.showToast({
      title: result?.error || '支付失败',
      icon: 'none',
      duration: 3000
    });
  }
} catch (error) {
  wx.hideLoading();
  console.error('支付失败:', error);
  wx.showToast({
    title: error?.msg || '网络请求失败',
    icon: 'none',
    duration: 3000
  });
}
```

### 6.2 获取余额（支付前检查）

```javascript
// 获取余额
const user_id = wx.getStorageSync('user_id');
const result = await ajax(
  `/wallet/balance?user_id=${user_id}`,
  'GET',
  {}
);

if (result?.msg === 'success') {
  const balance = parseFloat(result.data.balance || 0);
  const balanceFormatted = balance.toFixed(2);
  
  // 设置到 data 中
  this.setData({
    walletBalance: balance,
    walletBalanceFormatted: balanceFormatted
  });
  
  // 检查余额是否充足
  if (balance < orderAmount) {
    // 显示余额不足提示
    wx.showModal({
      title: '余额不足',
      content: `当前余额：¥${balanceFormatted}\n支付金额：¥${orderAmount.toFixed(2)}\n\n余额不足，请先充值`,
      confirmText: '去充值',
      cancelText: '取消',
      success: (res) => {
        if (res.confirm) {
          // 跳转到钱包页面
          wx.navigateTo({
            url: '/pkg_user/wallet/wallet'
          });
        }
      }
    });
  }
}
```

### 6.3 格式化金额数据

```javascript
// 打开支付弹窗时格式化金额
async openPayModal(order_id, amount) {
  const user_id = wx.getStorageSync('user_id');
  
  try {
    // 获取钱包余额
    const balanceResult = await ajax(`/wallet/balance?user_id=${user_id}`, 'GET', {});
    let balance = 0;
    if (balanceResult?.msg === 'success') {
      balance = parseFloat(balanceResult.data?.balance || 0);
    }
    
    // 格式化金额
    const payAmountNum = parseFloat(amount) || 0;
    const balanceNum = parseFloat(balance) || 0;
    
    this.setData({
      showPayModal: true,
      currentOrderId: order_id,
      payAmount: payAmountNum,                    // 数字类型，用于计算
      payAmountFormatted: payAmountNum.toFixed(2), // 字符串类型，用于显示
      walletBalance: balanceNum,                   // 数字类型，用于计算
      walletBalanceFormatted: balanceNum.toFixed(2) // 字符串类型，用于显示
    });
  } catch (error) {
    console.error('获取余额失败:', error);
    // 错误处理...
  }
}
```

---

## 7. 注意事项

1. **金额精度**
   - 所有金额相关操作都应使用 `DECIMAL` 类型，避免浮点数精度问题
   - 前端和后端都应进行金额格式验证
   - 前端显示金额时，必须在 JS 中格式化，不能在 WXML 中调用 `.toFixed()`

2. **数据格式化**
   - 微信小程序 WXML 模板中不能直接调用 JavaScript 方法
   - 所有需要格式化的数据（如金额、日期）都应在 JS 中格式化后再传递给 WXML
   - 建议同时保存原始数据（用于计算）和格式化数据（用于显示）

3. **并发安全**
   - 支付操作应使用数据库锁或乐观锁机制，防止并发支付导致余额计算错误
   - 建议使用数据库事务确保操作的原子性

4. **数据一致性**
   - 余额扣款和订单状态更新应保持一致性
   - 如果任何一步失败，应回滚整个操作

5. **安全性**
   - 所有接口都必须验证 `user_id`，防止越权操作
   - 必须验证订单属于当前用户
   - 建议对支付操作进行日志记录，便于审计和问题排查

6. **错误处理**
   - 前端应妥善处理各种错误情况，给用户友好的提示
   - 建议对网络错误、参数错误、业务错误进行分类处理
   - 余额不足时应引导用户去充值

7. **支付方式扩展**
   - 如果后续需要接入真实支付，建议保留钱包支付作为备选方案
   - 可以考虑添加支付方式选择功能（钱包支付、微信支付、支付宝等）

---

## 8. 后续扩展建议

1. **支付方式扩展**
   - 可以添加微信支付、支付宝等真实支付方式
   - 钱包支付可以作为快速支付方式保留

2. **支付记录查询**
   - 可以添加 `/payment/list` 接口，查询用户的支付历史记录

3. **退款功能**
   - 如果业务需要，可以添加退款功能接口
   - 退款时应将金额退回用户钱包

4. **支付超时**
   - 可以添加订单支付超时机制（如30分钟内未支付自动取消）
   - 可以使用定时任务或消息队列实现

5. **支付通知**
   - 如果接入真实支付，需要处理支付回调通知
   - 建议使用签名验证确保回调的安全性

---

## 9. 更新日志

| 日期 | 版本 | 更新内容 |
|------|------|----------|
| 2024-01-29 | 1.0.0 | 初始版本，订单支付接口文档（钱包支付） |
| 2024-01-29 | 1.1.0 | 修复支付弹窗数据显示问题，添加前端数据格式说明 |

---

## 10. 联系方式

如有问题，请联系后端开发团队。
